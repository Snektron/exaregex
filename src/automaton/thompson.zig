const std = @import("std");
const Allocator = std.mem.Allocator;
const Pattern = @import("../Pattern.zig");
const Nfa = @import("../automaton.zig").Nfa;

const Context = struct {
    b: Nfa.Builder,
    pattern: Pattern,

    const Error = error{
        OutOfMemory,
    };

    /// Add a single node to the state machine, starting at `start`. Returns the end node, where the
    /// paths generated by this node converge.
    fn compile(self: *Context, start: Nfa.StateRef, node: Pattern.Node) Error!Nfa.StateRef {
        const end = try self.b.addState(false);
        switch (node) {
            .empty => try self.b.addTransition(start, end, null),
            .any_not_nl => {
                var c: u8 = 0;
                while (true) {
                    if (c != '\n') {
                        try self.b.addTransition(start, end, c);
                    }
                    c +%= 1;
                    if (c == 0)
                        break;
                }
            },
            .char => |c| try self.b.addTransition(start, end, c),
            .char_set => |cs| {
                if (cs.invert) {
                    var bits = std.StaticBitSet(256).initEmpty();
                    for (cs.ranges) |range| {
                        var c = range.min;
                        while (true) : (c += 1) {
                            bits.set(c);
                            if (c == range.max)
                                break;
                        }
                    }

                    var it = bits.iterator(.{ .kind = .unset });
                    while (it.next()) |c| {
                        try self.b.addTransition(start, end, @as(u8, @intCast(c)));
                    }
                } else {
                    for (cs.ranges) |range| {
                        var c = range.min;
                        while (true) : (c += 1) {
                            try self.b.addTransition(start, end, c);
                            if (c == range.max)
                                break;
                        }
                    }
                }
            },
            .sequence => |seq| {
                var prev = start;
                for (self.pattern.children(seq)) |child| {
                    prev = try self.compile(prev, child);
                }
                try self.b.addTransition(prev, end, null);
            },
            .alternation => |seq| {
                const children = self.pattern.children(seq);
                if (children.len == 0) {
                    try self.b.addTransition(start, end, null);
                    return start;
                } else {
                    for (children) |child| {
                        const child_start = try self.b.addState(false);
                        const child_end = try self.compile(child_start, child);
                        try self.b.addTransition(start, child_start, null);
                        try self.b.addTransition(child_end, end, null);
                    }
                }
            },
            .repeat => |rep| {
                const loop_start = try self.b.addState(false);
                const loop_end = try self.compile(loop_start, self.pattern.nodes[rep.child]);

                try self.b.addTransition(start, loop_start, null);
                try self.b.addTransition(loop_end, end, null);

                // For ? and *, add the transition which bypasses the child entirely.
                switch (rep.kind) {
                    .zero_or_more, .zero_or_once => try self.b.addTransition(start, end, null),
                    else => {},
                }

                // For + and *, add the transition which loops around to the start of the loop.
                switch (rep.kind) {
                    .zero_or_more, .once_or_more => try self.b.addTransition(loop_end, loop_start, null),
                    else => {},
                }
            },
        }

        return end;
    }
};

/// Configuration options that may be passed to `thompson`.
pub const Options = struct {
    /// Special allocator used for temporary allocations.
    tmp_allocator: ?Allocator = null,
};

/// Perform the thompson construction: Given a regular expression, construct an
/// Nfa that matches the same language.
/// The final NFA is allocated using `a`. Optional `tmp_allocator` may be passed to perform
/// temporary allocations required during construction, but will default to `a`.
pub fn thompson(a: Allocator, pattern: Pattern, opts: Options) !Nfa {
    var ctx = Context{
        .b = Nfa.Builder.init(opts.tmp_allocator orelse a),
        .pattern = pattern,
    };
    defer ctx.b.deinit();

    const start = try ctx.b.addState(false);
    std.debug.assert(start == Nfa.start);
    const end = try ctx.compile(start, pattern.nodes[Pattern.Root]);
    ctx.b.states.items[end].accept = true;

    return try ctx.b.build(a);
}

test "thompson" {
    _ = thompson;
}
