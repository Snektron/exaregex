const std = @import("std");
const testing = std.testing;
const Allocator = std.mem.Allocator;
const Pattern = @import("../Pattern.zig");
const Nfa = @import("../automaton.zig").Nfa;
const parse = @import("../parse.zig").parse;

const Context = struct {
    b: Nfa.Builder,
    pattern: Pattern,

    const Error = error {
        OutOfMemory,
    };

    /// Add a single node to the state machine, starting at `start`. Returns the end node, where the
    /// paths generated by this node converge.
    fn compile(self: *Context, start: Nfa.StateRef, node: Pattern.Node) Error!Nfa.StateRef {
        const end = try self.b.addState(false);
        switch (node) {
            .empty => try self.b.addTransition(start, end, null),
            .any_not_nl => {
                var c: u8 = 0;
                while (true) {
                    if (c != '\n') {
                        try self.b.addTransition(start, end, c);
                    }
                    c +%= 1;
                    if (c == 0)
                        break;
                }
            },
            .char => |c| try self.b.addTransition(start, end, c),
            .char_set => unreachable, // TODO
            .sequence => |seq| {
                var prev = start;
                for (self.pattern.children(seq)) |child| {
                    prev = try self.compile(prev, child);
                }
                try self.b.addTransition(prev, end, null);
            },
            .alternation => |seq| {
                const children = self.pattern.children(seq);
                if (children.len == 0) {
                    try self.b.addTransition(start, end, null);
                    return start;
                } else {
                    for (children) |child| {
                        const child_start = try self.b.addState(false);
                        const child_end = try self.compile(child_start, child);
                        try self.b.addTransition(start, child_start, null);
                        try self.b.addTransition(child_end, end, null);
                    }
                }
            },
            .repeat => unreachable, // TODO
        }

        return end;
    }
};

/// Perform the thompson construction: Given a regular expression, construct an
/// Nfa that matches the same language.
pub fn thompson(a: Allocator, pattern: Pattern) !Nfa {
    var ctx = Context{
        .b = Nfa.Builder.init(a),
        .pattern = pattern,
    };
    defer ctx.b.deinit();

    const start = try ctx.b.addState(false);
    std.debug.assert(start == Nfa.start);
    const end = try ctx.compile(start, pattern.nodes[Pattern.Root]);
    ctx.b.states.items[end].accept = true;

    return try ctx.b.build(a); // TODO: use different allocator?
}

